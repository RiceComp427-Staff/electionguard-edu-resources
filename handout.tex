%%%%%%%%%%%%%%%%
% Set options

\newcommand{\settitle}{Project 1: Cryptographic Voting}
\newcommand{\course}{Comp427}
\newcommand{\coursename}{Intro to Computer Security}
\newcommand{\distdate}{February 12, 2021}
\newcommand{\duedateA}{Friday, February 19}
\newcommand{\duedateB}{Friday, February 26}

\usepackage{fullpage}
\usepackage{fancyvrb}
\usepackage[protrusion=true,expansion=auto]{microtype}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{mathptmx}
\usepackage{textcomp}
\usepackage[
  breaklinks=true,colorlinks=true,linkcolor=black,%
  citecolor=black,urlcolor=black,bookmarks=false,bookmarksopen=false,%
  pdfauthor={\course},%
  pdftitle={\settitle},%
  pdftex]{hyperref}
\urlstyle{sf}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{multicol}

\def\textsb#1{{\fontseries{sb}\selectfont #1}}
\newcommand{\kotlin}[1]{\ifthenelse{\boolean{kotlinShown}}{#1}{}}
\newcommand{\python}[1]{\ifthenelse{\boolean{pythonShown}}{#1}{}}
\newcommand{\kotlintt}[1]{\ifthenelse{\boolean{kotlinShown}}{{\tt #1}}{}}
\newcommand{\pythontt}[1]{\ifthenelse{\boolean{pythonShown}}{{\tt #1}}{}}
\newcommand{\kotlinftt}[1]{\ifthenelse{\boolean{kotlinShown}}{{\fbox{\tt #1}}}{}}
\newcommand{\pythonftt}[1]{\ifthenelse{\boolean{pythonShown}}{{\fbox{\tt #1}}}{}}

\newcommand{\problemsetdone}{\hfill$\Box{}$}

\newcommand{\htitle}
{
    \vbox to 0.25in{}
    \noindent\parbox{\textwidth}
    {
        \course\hfill \distdate\newline
        \coursename\hfill 
        \settitle \vspace*{-.5ex}\newline
        \mbox{}\hrulefill\mbox{}
    }
    \vspace{8pt}
    \begin{center}{\Large\bf{\settitle}}\end{center}
}
\newcommand{\handout}
{
    \thispagestyle{empty}
    \markboth{}{}
    \pagestyle{plain}
    \htitle
}

\newcommand{\problemsetheader}
{

This project has two due dates: {\bf \duedateA} and {\bf \duedateB},
both at {\bf 6\,p.m.}.  Late
submissions are not accepted.  If you have a conflict due to travel,
interviews, etc., please plan accordingly and turn in your homework
early.

\medskip

This is a group project; you will work in \textbf{teams of two} and
submit one project per team. Please find a partner as soon as
possible. If have trouble forming a team, post to the relevant Piazza
thread. The final exam will cover project material, so you and your
partner should collaborate on each part.

\medskip

The code and other answers your group submits must be entirely the
work of your group, and you are bound by the Honor Code. You may
consult with other students about the conceptualization of the project
and the meaning of the questions, but you may not look at any part of
someone else's solution or collaborate with anyone outside your group.
You may consult published references, provided that you appropriately
cite them (e.g., with program comments), as you would in an academic
paper. {\em Even though this project is based on code subject to
  an open source license, you may not redistribute your work, because
  that would constitute a violation of the Honor Code.}


\medskip

Once you have your partner, then you will use GitHub Classroom, via
this clone link. One of you goes first, and GitHub will ask for a name
for your ``team''. Please use your two Rice NetIDs with a hyphen
between them, e.g., {\tt abc12-def34}, as your team name. {\bf Do
  not visit the clone link until both you and your partner have agreed
  to work together.} GitHub makes it difficult to rearrange partnered
repositories, so we'd like to avoid this unless absolutely necessary.

\medskip

Before you do anything else, be sure to edit the {\tt README.md} file
to have your names, email addresses, and so forth, then commit the
file. Just to make sure you're not having any weird GitHub issues,
do this with separate commits: one from each partner editing their
name. That way, if there are weird GitHub problems, we'll know about
them as soon as possible.


\medskip
\begin{center}
\fbox{\url{https://classroom.github.com/a/XXXXXXXX}}
\end{center}

\hrulefill

\bigskip
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\handout
\setlength{\parindent}{0pt}
\problemsetheader
\setlength{\parindent}{20pt}

\tableofcontents

\vspace*{-15pt}
\section{Introduction}

This project gives you a sophisticated toolbox of primitives that are
useful for building ``end to end verifiable'' cryptographic voting systems,
including ElGamal cryptography (additively homomorphic) and
Chaum-Pedersen proofs. It's based on an open-source project from
Microsoft called ElectionGuard, which has multiple implementations
for different purposes. This assignment is based on the Python
``reference implementation''\footnote{\url{https://github.com/microsoft/electionguard-python}}
\kotlin{but is implemented in Kotlin}\python{but has substantial changes}.

The ``real'' ElectionGuard code has a number of features that are
useful for ``real'' elections, like understanding different ``ballot
styles'' (i.e., not every candidate appears on every ballot, but you
still want to be able to add ballots together). These features add
a huge amount of complexity that might get in your way of
understanding and using the code without a lot of study.

Consequently, we've stripped all the fancy stuff out and kept all the
cryptographic primitives. You'll be implementing ``simple'' elections,
where every ballot has exactly one contest on it, with the same
candidates on every ballot, and each voter gets to pick $k$ of the $n$
total candidates. These are simply added up, and whoever gets the
most wins.
(This is a modest generalization of the usual ``vote for one''
scheme, sometimes called ``first past the
post''\footnote{\url{https://en.wikipedia.org/wiki/First-past-the-post_voting}}.)

This project has two parts. You'll first encrypt, decrypt, and
validate ``selections'', which is to say, the individual choices that
a voter might make. For the second part, you'll move up one level of
abstraction and implement encryption, decryption, and validation for
whole ballots, as well as for the election tabulations.

For both parts, we've written extensive unit tests, leveraging
\python{the Python Hypothesis property-based testing
  library\footnote{\url{https://hypothesis.readthedocs.io/en/latest/}}}
\kotlin{the Java QuickTheories property-based testing
  library\footnote{\url{https://github.com/quicktheories/QuickTheories}}},
which will exercise your code with both positive examples (i.e., where
validation should succeed) and negative examples (i.e., where
validation should fail). (See Section~\ref{sec:properties} for more
details on property-based testing.) We're also going to ask you to write some of
your own unit tests that validate specific properties. Your grade will
be primarily based on which unit tests you pass and which unit tests
you fail. Of course, you're welcome to add any additional tests you
want, if you find that helpful, but {\em if you make any modifications to
existing tests, we will grade them as if they failed}.

\vspace{-6pt}
\subsection{Objectives}
\begin{itemize}\itemsep=0ex
\item Gain exposure to modern, real-world cryptographic techniques.
\item Learn to implement cryptographic code and validate its correctness.
\end{itemize}


\section{Setting up your computer}
\python{
This assignment generally requires you to set up your computer as one
would do for a modern Python3 development environment. There are a
number of good Python IDEs, like PyCharm, that you're welcome to use,
although you can run all the tests from the command-line, and that's
how we'll describe everything here.}
\kotlin{
This assignment generally requires you to set up your computer as one
would do for a modern Kotlin development environment, which pretty
much means installing IntelliJ IDEA along with any OpenJDK. You'll
also be able to run all the tests from the command-line, and that's
how we'll describe everything here.}


Once your computer is ready, you should install:
\begin{itemize}
\python{\item Python 3.8 (\url{https://www.python.org/downloads/})}

\kotlin{\item Any OpenJDK 8 or later. Azul notably provides builds
  that work on ARM computers like M1 Macs. (\url{https://www.azul.com/downloads/?package=jdk})}

\item (Mac only) Install the Apple command-line developer tools. Run
  \fbox{\tt xcode-select -{}-install} and click to accept the license.
  Alternately, you can install the full XCode from the app store.

\python{\item (Mac only) Install Homebrew (\url{https://brew.sh/})}

\item (Windows only) Install Git (\url{https://gitforwindows.org/}) -- this
  includes the ``Git Bash Shell'', where you can type the commands
  we'll show you. \python{You'll also need to install
    {\tt make}\footnote{\url{http://gnuwin32.sourceforge.net/packages/make.htm}},
    which you put in the {\tt mingw64/bin} directory.}

\item (Windows only) A fancier way to install Git is through
  Chocolatey, which also lets you easily install other commands
  you might want\python{ like {\tt make}, which you'll need
  for this project}. (Simple instructions:
\url{https://jcutrer.com/windows/install-chocolatey-choco-windows10},
more complex instructions: \url{https://chocolatey.org/install})
\end{itemize}

\noindent
\python{Earlier versions of Python won't work. This assignment hasn't been
tested against Python 3.9, so it might work or it might not.}

\section{Cloning from GitHub, setting up your environment}
If you're using a tool like \python{PyCharm}\kotlin{IntelliJ}, it will do all of this
automatically. You give it the GitHub URL, and it will clone
it locally.
\kotlin{You may need to tell IntelliJ where you installed your JDK,
  otherwise everything should ``just work''.}
\python{PyCharm might offer to set up a Python ``virtual environment''
  for you, but you should let {\tt make} do it for you and then tell
  PyCharm to use the virtual environment you just made.}

\python{Launch your favorite shell and go to the directory after the {\tt git
clone} process is complete. Run {\tt make}. This will run the
appropriate commands for Linux, Mac, or Windows, to download and
install all of the necessary dependencies. {\bf You need to do this,
  exactly once, even if you've already used PyCharm or another IDE
  to clone the repository.}}

\python{One way that you'll know you've succeeded is if that {\tt make}
  process gets all the way through to running the unit tests.}
\kotlin{Once installed, you should run the unit tests, either from
  IntelliJ, or by running \fbox{\tt ./gradlew test} on the command-line.}
Most of the unit tests should succeed, with others that will fail because you haven't
implemented the assignment yet.

Similarly, you can compare what you see on your own computer with
what happens every time you push some commits to GitHub, where all
the unit tests will be executed in a virtual environment
by GitHub Actions. You'll see a red X or green checkmark, telling you
whether the tests have failed or passed. You can click on that
and you'll then see a transcript of the unit tests running.

\section{Cryptographic basics}
There are several cryptographic things going on in ElectionGuard that
we didn't have time to cover in class, but that you really need to
understand.

When we introduced the digital signature algorithm, we mentioned that
it has two separate primes that it uses, $p$ and $q$, but we didn't
spend much time explaining why, except to say that we want our
exponents to be smaller, if we can get away with it without giving up
any cryptographic strength. (The text below was written by 
Josh Benaloh, a principal senior cryptographer at Microsoft Research,
who also designed the cryptography for ElectionGuard.)

The reason for two primes is that if you are doing computations in the
multiplicative subgroup modulo $p$, the elements are ${1,2,\ldots p-1}$. The
identity $1$ is always special, but since $p-1$ will not be prime (unless
$p=3$), some of the remaining elements will be able to be {\em distinguished}.
All elements $x$ will have the property $x^{p-1}\mod p = 1$, but many have
smaller order as well. For instance, every $x=y^2\mod p$ (quadratic
residues) has the property that $x^{(p-1)/2}\mod p = 1$, and this
property persists as these elements are raised to other powers. This
can compromise information that should be kept secret.
 

To avoid having distinguished elements, we like to use a {\em prime order
subgroup}. In many cases, we choose $p$ such that $(p-1)/2$ is prime and
just use the prime order subgroup consisting of all quadratic
residues. However, we can achieve the security of a very large $p$ by
using a much smaller subgroup defined by a smaller $q$ that divides
$p-1$. All of the elements of this smaller subgroup are generated by
$g^0,g^1, g^2,\ldots, g^{q-1}$, so we can get random elements with size $q$
exponents rather than size $p$ exponents. This makes everything
substantially more efficient. A $q$ just below $2^{256}$ also allows us to
match exponents nicely with SHA-256 outputs. So using $q$ as the largest
256-bit prime works very nicely.
 

One might then choose $p$ to be the largest 4096-bit prime such that
$p-1$ is a multiple of $q$ (which is what I did initially).  However,
having $p$ be close to a power of 2 (or otherwise representable as a
value of a polynomial with ``small'' coefficients) weakens its
resistance to discrete log attacks via the special number-field
sieve\footnote{\url{https://en.wikipedia.org/wiki/Special_number_field_sieve}}.
It is desirable to have parameters generated deterministically to
avoid concerns that there may be some hidden back door.  I tried to
find a clean way to do this, but every attempt that I made wound up
being representable as a polynomial with small coefficients.  I
therefore did what everyone else does and used an unrelated
mathematical constant to deterministically produce $p$.  Both $\pi$
and $e$ are overused for this purpose, and the description is slightly cleaner
if the constant is less than one and greater than one half, so I wound
up with the Euler-Mascheroni
constant\footnote{\url{https://en.wikipedia.org/wiki/Euler-Mascheroni_constant}}.
For computational efficiency,
there is some benefit to having all of the extreme high-order bits and
low-order bits be one, so this drove the selection of a suitable $p$.

% \paragraph{Extra fun.} When we're running the unit tests, they're
% really slow because $p$ and $q$ are so large. Can you find smaller
% values of $p$ and $q$ that can satisfy the properties above, allowing
% the unit tests to run significantly faster? Would that compromise or
% enhance their ability to find bugs? How might you engineer the
% ElectionGuard library so it's never accidentally in {\em test mode}
% during production use?

\section{ElGamal encryption and related proofs}
Normal ElGamal encryption, invented in 1985 by Tahir
ElGamal\footnote{\url{https://ieeexplore.ieee.org/document/1057074}}, is very straightforward. If
you have a secret key $a$ in $[0,q)$, the corresponding public key is
$g^a \mod p$, in $[0,p)$. (We'll stop writing the $p$, $q$, and mod
parts because they just overcomplicate the equations.) It's safe to
share $g^a$ with anybody because it's (believed to be) very hard to recover
$a$. This is called the ``discrete log problem'' (see also, the
not entirely identical ``decisional Diffie-Hellman
problem''\footnote{\url{https://en.wikipedia.org/wiki/Decisional_Diffie\%E2\%80\%93Hellman_assumption}},
which is the actual hard problem we're counting on for ElGamal
encryption).

Because we're interested in having an {\em additive homomorphism},
where we can ``add'' together two encryptions and get another
encryption, we're going to use a variant called ``exponential
ElGamal''. With this, we put the message $m$ we're encrypting
into an exponent. For voting, these messages are mostly going to
be 0-or-1, representing a voter's selection or absence of a selection,
so it's important that the cryptosystem have an input that ensures
a wide distribution of possible ciphertexts. That's a random number
$r$ called a nonce. We can now define encryption and decryption as
follows:
\begin{align*}
c &= \mathrm{Encrypt}(m, r, g^a) = \left<g^r, g^{ar}g^m\right> \\
p &= \mathrm{Decrypt}(c, a) \\
  &= \mathrm{Decrypt}(\left<g^r, g^{ar}g^m\right>, a) & \mathrm{note:} \left({g^r}\right)^a = \left({g^a}\right)^r = g^{ar} \\
  &= \mathrm{DLog}_g\left(g^{ar}g^m * \left(g^{ar}\right)^{-1}\right) \\
  &= \mathrm{DLog}_gg^m \\
  &= m
\end{align*}
Note that $\mathrm{DLog}_gg^m$ is only efficiently computable for
relatively small $m$, since our implementation uses {\em memoization}
to build a table $\left[1, g, g^2,
g^3, ...\right]$.\footnote{We could trade space for time, using an
algorithm called ``baby-step, giant-step'' by Daniel Shanks.
\url{https://en.wikipedia.org/wiki/Baby-step_giant-step}; see also
rainbow tables. \url{https://en.wikipedia.org/wiki/Rainbow_table}} Multiplicative inverses, however, are always
efficient to find, for any value in the group. In particular, we know
that $\forall x: x^q \mod p = 1$, by virtue of how we've set up $p$
and $q$, so therefore an easy way to find $x^{-1}$ is just $x^{q-1}$
because $x * x^{q-1} = x^q = 1$. Alternatively, a efficient way to
compute inverses would be to use the extended Euclidean algorithm\footnote{\url{https://en.wikipedia.org/wiki/Extended\_Euclidean\_algorithm\#Computing\_multiplicative\_inverses\_in\_modular\_structures}}.


\subsection{Homomorphic accumulation}
With this definition of ElGamal encryption, we can define an
accumulation operation using piecewise multiplication:
\begin{align*}
c_1 &= \mathrm{Encrypt}(m_1, r_1, g^a) = \left<g^{r_1}, g^{a{r_1}}g^{m_1}\right>\\
c_2 &= \mathrm{Encrypt}(m_2, r_2, g^a) = \left<g^{r_2}, g^{a{r_2}}g^{m_2}\right>\\
c_1 \oplus c_2 &= \left<g^{r_1}, g^{a{r_1}}g^{m_1}\right> \oplus \left<g^{r_2}, g^{a{r_2}}g^{m_2}\right>  \\
&= \left<\left(g^{r_1}\right)\left(g^{r_2}\right), \left(g^{a{r_1}}g^{m_1}\right)\left(g^{a{r_2}}g^{m_2}\right)\right> \\
&= \left<g^{r_1 + r_2}, g^{a(r_1 + r_2)}g^{m_1 + m_2}\right>\\
&= \mathrm{Encrypt}(m_1 + m_2, r_1 + r_2, g^a)
\end{align*}
Any intermediary can compute the homomorphic sum $(\oplus)$ of these encryptions
without needing to decrypt, and without needing to know the secret
key.

\subsection{Key sharing}
\label{sec:keyshare}

The real ElectionGuard library supports a sophisticated ``threshold
cryptography'' system
which allows multiple trustees to each have a ``share'' of the
election's key material. These shares are combined into a single
public key, that all the voting machines use. For decryption
operations, it takes a (predefined) $k$ of the $n$ trustees to
collaborate together in order to do any decryption operation.
This ``key ceremony'' is a bit complicated.

As a warmup, you'll be implementing a simplified version, where
all of the key shareholders need to work together. Here's how it
works. Let's say we have $n$ trustees, and each has secret keys $a_i$
and public keys $g^{a_i}$. We can define a joint public key by
simply multiplying them all together:
\begin{align*}
k_{\mathrm{joint}}&= g^{a_1}g^{a_2} \cdots g^{a_n}\\
&= g^{a_1 + a_2 + \cdots a_n}
\end{align*}
                                                                 
Multiplying together the public keys yields a joint key, where we know
the {\em formula} for the exponent, even though we can't derive the
{\em value} for it. So, it a message is encrypted with this joint key,
we need a way for the trustees to collaboratively decrypt it.

\begin{align*}
\mathrm{PartialDecrypt}(c, a_i) &= \mathrm{PartialDecrypt}\left(\left<g^r, g^{(a_1 + a_2 \cdots a_n)r}g^m\right>,a_i\right) \\
\mathrm{DecryptionShare}_i &= ({g^r})^{a_i} = g^{a_ir} \\
\prod_i \mathrm{DecryptionShare}_i &= g^{a_1r}g^{a_2r}\cdots g^{a_nr} \\
&= g^{(a_1 + a_2 \cdots a_n)r}
\end{align*}

Each decryption share is nothing more than the nonce padding $g^r$
raised to the secret key share $a_i$, and then we can just multiply
those shares together and we get exactly the value that's multiplied
with $g^m$. As before, multiplicative inverses are easy to find, so
we have everything we need to combine ``partial decryptions'' together
to yield the complete decryption. (This is a warm-up exercise that
you'll do to get things rolling for part~1 of the assignment.)


\subsection{Chaum-Pedersen proofs}
\label{sec:chaum-pedersen}
You'll see several different kinds of Chaum-Pedersen proof objects
in \pythontt{chaum\_pedersen.py}\kotlintt{ChaumPedersen.kt}:
\begin{description}
\item[DisjunctiveChaumPedersenProofKnownNonce] demonstrates that the prover knows
  the secret nonce used to create an encryption that's either a $1$ or $0$.
\item[ConstantChaumPedersenProofKnownNonce] demonstrates that the prover
  knows the secret nonce used to create an encryption that's a
  constant (not just $0$ or $1$).
\item[ConstantChaumPedersenProofKnownSecretKey] demonstrates that the prover
  knows the secret key used to create an encryption that's a
  constant (not just $0$ or $1$).
\item[GenericChaumPedersenProof]
  is used by all of the above proofs. It provides a proof that two
  tuples $(g, g^x), (h, h^x)$ share the same exponent $x$ without
  revealing it.
\end{description}

\paragraph{So, when do you use which sort of proof?}
When you are {\em encrypting a counter that might be one or zero}, you
make a disjunctive proof. You'll need to hang on to the nonce that you
used to do the encryption. You'll ultimately output one proof per encrypted
counter.

When you are {\em proving that the voter cast at most $k$ votes on the ballot},
you could theoretically sum them up and use a disjunctive proof, but
that would only really work with $k=1$, and we want to be more
general, which would make a disjunctive proof
much more complicated. Instead, what you'll do is create zero or more
``placeholder'' candidates (literally, their name will be
``PLACEHOLDER'' with an integer after that). If all the other candidates got zero votes, then the
placeholder(s) gets one. Otherwise, the placeholder(s) gets zero, such
that the sum of the candidate slots plus the placeholder slots is
exactly $k$. Each
placeholder ciphertext has the same disjunctive proof as all the real candidates.
And now here's the cool part: you just use the additive homomorphism
of ElGamal, and generate a {\em constant} Chaum-Pedersen proof, that
the sum of all the candidates, including the placeholder(s), is exactly
$k$.

When you are {\em decrypting the tally and proving that the announced
  plaintext is correct}, you use the decryption proof, which doesn't
require the nonce, but does require the decryption (secret) key. This
corresponds to something the election official might compute when the
election is complete. You'll see each of these Chaum-Pedersen proof
types listed as part of the various data structures in
\pythontt{simple\_election\_data.py}\kotlintt{SimpleElectionData.kt},
so you'll know which one to use where.

Fun fact: in the special case where $k=n$, we wouldn't need this
placeholder construction, because we wouldn't need to restrict the total
number of cast votes. This voting method is called ``approval
voting''\footnote{\url{https://en.wikipedia.org/wiki/Approval_voting}};
not only does it simplify our proofs, but it also improves usability for voters by
eliminating the possibility of a ballot being discarded by virtue of
being ``overvoted''. Of course, if a voter selected {\em all} $n$
candidates, their vote would be valid, but it wouldn't have any meaningful
influence on the winner.

\paragraph{So, how do those proofs work?}
We cover this in more detail in our lecture. For the purposes of this assignment,
what matters is that you understand what a ``generic'' Chaum-Pedersen
proof actually proves, which then enables the more specific versions of the proof
to use it as a subroutine. So, if we want to prove that the encryption
of $m=3$ is actually three, based on our knowledge of the encryption
nonce $r$, then we're going to be generating a proof that $(g, g^r)$
and $(g^a, g^{ar})$ share the nonce $r$ without revealing $r$. And that
value $g^{ar}$ is just the right-hand side of the ElGamal
encryption, after we multiply it with $g^{-3}$ (i.e., canceling
out the $g^m$ where $m=3$).

This might not seem very exciting, but it's the same math when we're
proving that the {\em sum of the encrypted counters} is exactly the
constant $k$ for a $k$-of-$n$ election. When you combine that with
proofs, for each counter, that they are exactly 0 or 1, you end up
with a proof, publicly verifiable, that you have a {\em well-formed
  ballot}. No overvotes. No funny business. This gives public
observers of an election the ability to verify important properties of
the election tally without compromising any individual ballot's privacy!

\paragraph{What if the voter selects more than $k$ candidates?}
The voter has expressed a ballot that is not valid. There's no way for
you to produce an encrypted ballots, with all of the valid proofs.
Since exactly this can and will happen in the real world, you'll need
to deal with this, in part~2 of the assignment. You'll need to
``interpret'' these overvoted ballots into undervotes (i.e., no
selections at all) before encrypting them. Note that this means that
the decryption of the encryption of an overvoted ballot is going to be
different from the original selections!

\subsection{Nonces and nondeterminism}
\label{sec:nonces}
You'll see {\tt seed}, \pythontt{hash\_header}\kotlintt{hashHeader}, and other
such names for arguments to many of your functions. The important
concept is that {\bf all your code should be deterministic}. The same
inputs should always yield the same outputs. These seed values are
where you get your nondeterminism. When you're encrypting a ballot
that has five counters, you'll need five individual random numbers.
You can derive them from the seed using the code in \pythontt{nonces.py}\kotlintt{Nonces.kt}. 

The broad idea, then, is that every ``real world'' ballot will start
with a single, true-random number, and from that, all of the other
random $r$ values for the encryptions, and everywhere else they're
needed, will be derived from that initial seed.

You want to implement this as a hierarchical process. From the master
seed, you'll derive seeds for each ballot. Then from the ballot seeds,
you'll derive seeds for each selection. Each layer of code passes the seed
values down to the next layer of code. You can convert one seed into
as many as you need by using the code in \pythontt{nonces.py}\kotlintt{Nonces.kt}.

\paragraph{Extra fun.} Imagine that we have hand-marked paper ballots
being fed into a scanner with a reasonably fast computer but not
enough storage for the ballot ciphertexts (real world ElectionGuard
ciphertexts can be multiple megabytes of data per ballot). If we
printed a unique master seed as a barcode on the bottom of each
ballot, then the scanner could compute the full encryption, if it
wanted, printing the voter a ``receipt'' which is really just the hash
of their encrypted ballot. {\em Then the machine can completely forget
the ciphertext} because it can be recomputed later, identically, due to the
deterministic architecture of how nonces are derived from seeds.

\section{The ElectionGuard library}
If you look in the
\pythontt{src/electionguard}\kotlintt{src/main/kotlin/electionguard}
directory, you'll see a
number of files. Here's what each of them does:

\begin{description}
\item[\python{chaum\_pedersen.py}\kotlin{ChaumPedersen.kt}]
  Implementations of several different Chaum-Pedersen proofs
  (see Section~\ref{sec:chaum-pedersen}).
\item [\python{dlog.py}\kotlin{DLog.kt}] Implements a caching, brute-force discrete log engine.
  So long as the exponent is on the small side (millions, not
  billions), this will run efficiently. We need this to undo the
  $g^v$ exponentiation applied to the plaintext vote counter $v$.
\item [\python{elgamal.py}\kotlin{ElGamal.kt}] Implements ``exponential ElGamal'' encryption and
  decryption. Also, this is where you'll implement ``key sharing''
  (see Section~\ref{sec:keyshare}).
\item [\python{group.py}\kotlin{Group.kt}] Implements {\tt ElementModQ}, {\tt ElementModP}, and
  a variety of function wrappers to compute with them. All of this
  bottoms out to calls to the \python{GNU MultiPrecision
    library}\kotlin{Java BigInteger class}, which has
  fast, hand-tuned C and assembly code.
\item [\python{hash.py}\kotlin{Hash.kt}] Implements a wrapper around SHA-256 hashing, where
  you can hash just about anything, including lists, and get out
  an {\tt ElementModQ}.
\python{
\item [logs.py] Implements a wrapper around Python's logging facility.
  Logs go to the screen, and you have some flexibility to configure
  things, where everything goes to a file and only some things go to
  the screen. You'll see lots of calls to the logging functions
  throughout the rest of the code.
}
\item [\python{nonces.py}\kotlin{Nonces.kt}] Often you'll want to start with some seed value
  and generate a stream of nonces that you need to be different from
  one another, but deterministically derived from the seed. This code
  gives you a \python{Python Sequence}\kotlin{Kotlin class instance}, which you can treat as if it's
  an array of infinite length, giving you random access to any element.
  Optional ``headers'' (typically, just another string) will be hashed
  together with the given seed value, making it easy for you to create
  multiple nonce streams, which you might use for different purposes,
  from the same original seed value (see Section~\ref{sec:nonces}).
\item
  [\python{simple\_election\_data.py}\kotlin{SimpleElectionData.kt}] This defines all the input and output
  types for the code you'll be writing. This is the
  \python{Python}\kotlin{Kotlin} equivalent
  of C {\tt struct} definitions. \python{(We deliberately avoided using too many
  fancy object-oriented features, to keep our code cleaner,
  making it hopefully more readable by non-experts in the language.)}
\kotlin{(We tried to avoid using too many of Kotlin's crazier
  functional or object-oriented features, to make our code more
  readable by non-experts, although we do use Kotlin extension
  functions\footnote{\url{https://kotlinlang.org/docs/extensions.html}}
  extensively.)}
\item [\python{simple\_elections.py}\kotlin{SimpleElections.kt}] This is where you'll be doing most of
  your work. We've defined all the functions you need to implement,
  including their argument and return types, but we've left most of
  the bodies empty.
\item [\python{utils.py}\kotlin{Utilities.kt}] A handful of general-purpose utility functions that are
  used in various places.
\end{description}
  
\subsection{Testing}
You'll find corresponding unit test files in the
\pythontt{tests}\kotlintt{test} directory. If you read those tests, you'll see that they
make extensive use of the \python{Hypothesis}\kotlin{QuickTheories} property-based testing library,
which allows inputs to be generated at random.
In
\pythontt{src/electionguardtest}\kotlintt{src/test/kotlin/electionguard/Generators.kt},
you'll see the ``generator'' functions
\python{(called
``composites'' in Hypothesis)} that can produce these random values.
\python{Unfortunately, Hypothesis and mypy (Python's static type annotation
checker) don't get along nicely, so we cannot annotate the generators
with their return type. If you follow the patterns of other unit
tests, you should be able to avoid too many weird type errors.}
\kotlin{Unfortunately, QuickTheories normally only likes to generate
  at most four arguments at a time, but we often need more than that,
  so we had to cobble together ``tuples'' of various sizes for
  QuickTheories to generate more things at once. It make the code
  a little bit uglier, but it all works.}

\subsection{Property-based testing}
\label{sec:properties}
If you've never worked with property-based testing before, you can
think of it as a form of fuzz testing, where the computer generates
randomly chosen inputs, as part of the unit testing process, and then
assertions are made about the code. A simple example property might be
asserting that decryption is the inverse of encryption, i.e.,
$\forall x: \mathrm{Decrypt}(\mathrm{Encrypt}(x)) = x$. A
property-based testing library will automate the process of generating
inputs and running the tests. If it finds a {\em counterexample}, an
optional but helpful feature is called {\em shrinking}, where it will
try to search for a ``simpler'' counterexample to present to you,
which will help you better understand your bug. \python{We've disabled
  shrinking, by default for most Hypothesis tests, because it's very
  slow.}

Scott Wlaschin has produced an excellent introduction to property-based
testing\footnote{\url{https://fsharpforfunandprofit.com/pbt/}} -- a
50-minute YouTube video plus a variety of written blog posts. His
example code is all in F\#, but his explanations apply
perfectly to our use of \kotlin{QuickTheories in Kotlin}\python{Hypothesis in Python}.

\section{Submission Strategy \& Engineering}

All of the code elements that you must implement are conveniently
labeled {\tt TODO} for you and will mention ``part~1'' or ``part~2''.
You'll notice some of these {\tt TODO} comments are in the unit tests,
themselves. Each {\tt TODO} item explains what you're supposed to do,
so we won't reiterate those here.

Generally speaking, part~1 is a warm-up, where you're learning your
way around the codebase, and part~2 is where you're dealing with
ballots having k-of-n votes cast. Of note, in part~1, you'll start
off by implementing ElGamal key sharing (see \ref{sec:keyshare}),
which involves editing code in \python{elgamal.py}\kotlin{ElGamal.kt}.
Everything else you'll do is in \python{simple\_elections.py}\kotlin{SimpleElections.kt}
and the associated unit test files.

You should adopt a ``commit and push, early and often'' strategy.
While we're not specifically instructing you in how you should
collaborate with your partner, some variant of pair programming will
be invaluable, where one of you is typing and sharing their screen,
while the other is looking over and offering suggestions. Certainly,
Git makes it straightforward for you to work on separate items and
merge them later, but you're less likely to understand the full
project. Trade-off who is typing and who is assisting. Don't just say
``I know how to do this. You just watch and maybe clean it up later.''

The unit tests will all run on GitHub as part of GitHub Actions. It's
generally faster and easier to run them on your own computer. You can
do this inside your favorite IDE, or you can run \pythonftt{make
  test}\kotlinftt{./gradlew test} from
your commandline.
\python{
If you get weird errors, you might run {\tt pipenv
  shell} beforehand, which ensures that you're using the Python
virtual environment for the subsequent commands you want to run.
You should also run \fbox{\tt make lint}, which will run {\tt black} (the
code indenter) and {\tt mypy} (the static type checker). If {\tt
  black} rejects your code indentation, you can fix that by instead
running \fbox{\tt make auto-lint} or running \fbox{\tt black src tests} on the
command-line.}
\kotlin{You should also run \fbox{\tt ./gradlew formatKotlin} to make
  sure your code is nicely formatted.}

The autograder is also available to you from the commandline.
Just run \pythonftt{make autograder}\kotlinftt{./gradlew clean autograder}.
That should get you results identical to what the graders see
on GitHub Actions.

\paragraph{When you finish part 1.} You're going to want to use a Git
tag. You do this after you're satisfied that you've completed the
requirements. You then say {\tt git tag part1} and {\tt git push
  -{}-tags}. Alternately, you can use the GitHub website to create a
``release'', which in turn creates a Git tag. Your grader will
examine your code, at this tag, and the output of GitHub Actions
when running the unit tests on this tag. Or, if you haven't done
this, your grader will just look at whatever you've pushed prior
to the deadline.

\paragraph{Continuing with part 2.} You can march right ahead with
part~2, even if that means breaking something from part~1. Your
grader will examine whatever you have committed and pushed prior to the
final deadline. If you want to keep playing with the code afterwards,
please make a {\tt part2} tag, as above, and then that will
be the focus of the graders' attention.

\paragraph{What if it works on my computer and fails on GitHub
  Actions?} Your grade is based on what the grader sees running on
GitHub Actions. Perhaps you changed a file on your local machine and
didn't commit or push the changes to the server. When in doubt,
find one of the TAs or the professor and ask for help if you're
seeing these sorts of discrepancies.

\paragraph{Am I allowed to add imports to the files?} Absolutely. If
there's a function you need that isn't already imported, then feel
free to import it. That includes functions from the ElectionGuard
library, or otherwise available from the standard
\python{Python}\kotlin{Kotlin} libraries.
You shouldn't need to add or change any external dependencies in
\python{Pipfile}\kotlin{build.gradle}.

\paragraph{Am I allowed to add helper functions and/or additional unit
  tests?} Sure. Just don't change the type signatures or any of the
other existing code that we've provided for you. In particular,
if you make changes to any of the unit tests used by the autograder,
your human grader will treat that test as having failed and will
subtract the appropriate points.

\paragraph{I'm seeing a ton of warnings on the console...} Many of the
functions that you're given, when they discover an error, will
log about it, and then indicate a failure as part of their return
value. Some unit tests will exercise these errors, causing all
the logging output as a side-effect, but what really matters to
you is whether the unit tests pass or fail.

\section{Grading}

This project is worth a total of twenty points.

\paragraph{Part 1 (worth 10 points).} You must implement several functions and unit
tests. Your grader will look to make sure all tests from
\pythontt{test\_simple\_elections\_part1.py}
\kotlintt{SimpleElectionsTestPart1} pass. You get one point for
your code passing \pythontt{mypy}\kotlin{the Kotlin compiler}
with no warnings or errors.

\paragraph{Part 2 (worth 10 points).} The remaining unit tests, in
\pythontt{test\_simple\_elections\_part2.py}
\kotlintt{SimpleElectionsTestPart2}, are collectively worth
9/10 points. The remaining point is assessed by your human
grader, looking at your {\tt README.md} file, where you're
asked to answer some questions, based on building a simple benchmark.

We're only including \pythontt{mypy}\kotlin{the Kotlin compiler} once
in the grading rubric, but if your part~1 submission is fine and your
final submission has warnings or errors, we'll still take off the point.

\end{document}
